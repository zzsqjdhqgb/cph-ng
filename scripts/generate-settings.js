// Copyright (C) 2025 Langning Chen
//
// This file is part of cph-ng.
//
// cph-ng is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// cph-ng is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with cph-ng.  If not, see <https://www.gnu.org/licenses/>.

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const packageJsonPath = path.join(__dirname, '../package.json');
const settingsPath = path.join(__dirname, '../src/helpers/settings.ts');

const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
const configurations = packageJson.contributes.configuration;

const header = `// THIS FILE IS AUTO-GENERATED BY scripts/generate-settings.js
// DO NOT EDIT THIS FILE MANUALLY

import { ConfigurationTarget, workspace } from 'vscode';
import { renderPath } from '@/utils/strTemplate';
import Logger from './logger';

class SettingsSection {
  protected logger: Logger = new Logger('settings');
  constructor(private name: string) {}
  protected get<T>(key: string, defaultValue: T): T {
    const fullKey = \`\${this.name}.\${key}\`;
    const value = workspace.getConfiguration('cph-ng').get(fullKey);
    this.logger.trace('Getting setting', fullKey, value);

    if (value === undefined) {
      return defaultValue;
    }

    if (Array.isArray(defaultValue)) {
      if (!Array.isArray(value)) {
        this.logger.warn(\`Setting \${fullKey} has invalid type (expected array), using default value\`);
        return defaultValue;
      }
      if (defaultValue.length > 0) {
        const elementType = typeof defaultValue[0];
        if (!value.every((v: any) => typeof v === elementType)) {
          this.logger.warn(\`Setting \${fullKey} has invalid array element type (expected \${elementType}), using default value\`);
          return defaultValue;
        }
      }
      return value as T;
    }

    const expectedType = typeof defaultValue;
    if (expectedType === 'object' && defaultValue !== null) {
      if (typeof value !== 'object' || value === null) {
        this.logger.warn(\`Setting \${fullKey} has invalid type (expected object), using default value\`);
        return defaultValue;
      }
      return value as T;
    }

    if (typeof value !== expectedType) {
      this.logger.warn(\`Setting \${fullKey} has invalid type (expected \${expectedType}, got \${typeof value}), using default value\`);
      return defaultValue;
    }

    return value as T;
  }
  protected set(key: string, value: unknown): Thenable<void> {
    this.logger.trace('Setting setting', \`\${this.name}.\${key}\`, value);
    return workspace
      .getConfiguration('cph-ng')
      .update(\`\${this.name}.\${key}\`, value, ConfigurationTarget.Global);
  }
}
`;

let content = header;
const sections = [];

// Helper to determine TS type from JSON schema
function getTsType(prop) {
  if (prop.enum) {
    return prop.enum
      .map((e) => (typeof e === 'string' ? `'${e}'` : e))
      .join(' | ');
  }
  if (prop.type === 'array') {
    if (prop.items && prop.items.type) {
      return `${prop.items.type}[]`;
    }
    if (prop.items && prop.items.enum) {
      return `(${prop.items.enum.map((e) => (typeof e === 'string' ? `'${e}'` : e)).join(' | ')})[]`;
    }
    return 'any[]';
  }
  return prop.type || 'any';
}

// Helper to format default value
function formatDefaultValue(val) {
  if (val === undefined) {
    return 'undefined';
  }
  return JSON.stringify(val);
}

const configList = Array.isArray(configurations)
  ? configurations
  : [configurations];

for (const config of configList) {
  // Extract section name from the first property (e.g. cph-ng.basic.folderOpener -> basic)
  const firstKey = Object.keys(config.properties)[0];
  const match = firstKey.match(/^cph-ng\.([^.]+)\./);
  if (!match) {
    continue;
  }

  const sectionName = match[1];
  const className =
    sectionName.charAt(0).toUpperCase() + sectionName.slice(1) + 'Section';
  sections.push({ name: sectionName, className });

  content += `\nclass ${className} extends SettingsSection {
  constructor() {
    super('${sectionName}');
  }
`;

  for (const [key, prop] of Object.entries(config.properties)) {
    const shortKey = key.split('.').pop();
    const type = getTsType(prop);
    const defaultValue = formatDefaultValue(prop.default);

    // Special handling for cache.directory
    if (key === 'cph-ng.cache.directory') {
      content += `  get ${shortKey}(): ${type} {
    return renderPath(this.get('${shortKey}', ${defaultValue}));
  }
`;
      continue;
    }

    content += `  get ${shortKey}(): ${type} {
    return this.get('${shortKey}', ${defaultValue});
  }
`;

    // Special handling for companion.submitLanguage setter
    if (key === 'cph-ng.companion.submitLanguage') {
      content += `  set ${shortKey}(value: ${type}) {
    this.set('${shortKey}', value);
  }
`;
    }
  }

  content += `}\n`;
}

content += `\nexport default class Settings {
`;

for (const section of sections) {
  content += `  static ${section.name} = new ${section.className}();\n`;
}

content += `}\n`;

fs.writeFileSync(settingsPath, content);
console.log(`Generated ${settingsPath}`);
